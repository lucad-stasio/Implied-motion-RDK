<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Motion Adaptation RDK — Fixed Implementation</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="https://unpkg.com/jspsych@latest/css/jspsych.css">
    <style>
      html, body { margin: 0; padding: 0; height: 100%; background: #808080; }
      #rdk-canvas { display: block; margin: 0 auto; background: #808080; }
      .center { color: #ddd; max-width: 800px; margin: 40px auto; line-height: 1.6; }
      .center h2, .center h3 { color: #fff; }
    </style>
    <script src="https://unpkg.com/jspsych@latest/dist/index.browser.js"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@latest/dist/index.browser.js"></script>
  </head>
  <body></body>
  <script>
    const jsPsych = initJsPsych({});

    let pixelsPerDegree = null;
    const apertureDeg = 5;
    const densityDotsPerDeg2 = 50;
    const dotDiameterDeg = 0.05;
    const dotSpeedDegPerSec = 2;
    const lifetimeMs = 200;
    const coherence = 0.40;
    const interleavedSets = 3;

    const fixationDurationMs = 1500;
    const adaptorDurationMs = 1500;
    const testDurationMs = 2000;
    const itiMinMs = 1000;
    const itiMaxMs = 2000;

    // Global canvas and context to reuse
    let globalCanvas = null;
    let globalCtx = null;
    let currentRafId = null;

    const timeline = [];

    function initGlobalCanvas(width = 800, height = 800) {
      if (!globalCanvas) {
        globalCanvas = document.createElement('canvas');
        globalCanvas.id = 'rdk-canvas';
        globalCanvas.width = width;
        globalCanvas.height = height;
        globalCtx = globalCanvas.getContext('2d');
        globalCtx.imageSmoothingEnabled = false;
      }
      return globalCanvas;
    }

    function cleanup() {
      if (currentRafId) {
        cancelAnimationFrame(currentRafId);
        currentRafId = null;
      }
    }

    const calibrate = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: () => `
        <div class="center">
          <h2>Display Calibration</h2>
          <p>Enter your monitor width (in cm) and your viewing distance (in cm).</p>
          <p>This will scale dot size, speed, and density to degrees of visual angle.</p>
          <div style="margin:12px 0;">
            <label>Monitor width (cm): <input id="mon_cm" type="number" step="0.1" min="10" style="width:100px" value="38"></label>
            &nbsp;&nbsp;
            <label>Viewing distance (cm): <input id="dist_cm" type="number" step="0.1" min="20" style="width:100px" value="54"></label>
          </div>
          <p>Press any key to continue.</p>
        </div>
      `,
      choices: 'ALL_KEYS',
      on_load: () => {
        const el = document.getElementById('mon_cm');
        if (el) el.focus();
      },
      on_finish: () => {
        const monCm = parseFloat((document.getElementById('mon_cm') && document.getElementById('mon_cm').value) || '38');
        const distCm = parseFloat((document.getElementById('dist_cm') && document.getElementById('dist_cm').value) || '54');
        const screenPx = Math.max(window.screen.width, window.innerWidth) * (window.devicePixelRatio || 1);
        const pxPerCm = screenPx / monCm;
        const cmPerDeg = 2 * distCm * Math.tan(Math.PI / 360);
        pixelsPerDegree = pxPerCm * cmPerDeg;
        initGlobalCanvas();
      }
    };

    const instructions = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <div class="center">
          <h2>Motion Adaptation with Random-Dot Kinematogram</h2>
          <p>Each trial: ITI (1–2 s) → fixation (1.5 s) → <b>grating adaptor</b> (1.5 s) → <b>RDK test</b> (max 2 s).</p>
          <p>Respond to the <b>RDK test</b> with arrow keys: Left/Right for motion direction.</p>
          <p>On timeouts, "Too Slow!" appears and the trial will be repeated later.</p>
          <p>Press any key to begin.</p>
        </div>
      `
    };
    timeline.push(calibrate, instructions);

    function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }

    function fixationTrial({ width = 800, height = 800 } = {}) {
      return {
        type: jsPsychHtmlKeyboardResponse,
        choices: 'NO_KEYS',
        trial_duration: fixationDurationMs,
        stimulus: () => {
          const canvas = initGlobalCanvas(width, height);
          return canvas.outerHTML;
        },
        on_load: () => {
          cleanup();
          
          const canvas = document.getElementById('rdk-canvas');
          if (!canvas) return;
          
          const ctx = canvas.getContext('2d');
          const ppd = pixelsPerDegree || 50;
          const radius = Math.max(1, Math.round(0.25 * ppd));
          const cx = Math.floor(width / 2);
          const cy = Math.floor(height / 2);
          
          ctx.fillStyle = '#808080'; // neutral gray background
          ctx.fillRect(0, 0, width, height);
          ctx.fillStyle = '#000000'; // black fixation dot
          ctx.beginPath();
          ctx.arc(cx, cy, radius, 0, Math.PI * 2);
          ctx.fill();
        }
      };
    }

    function gratingAdaptor({ width = 800, height = 800, directionDeg = 0 } = {}) {
      return {
        type: jsPsychHtmlKeyboardResponse,
        choices: 'NO_KEYS',
        trial_duration: adaptorDurationMs,
        stimulus: () => {
          const canvas = initGlobalCanvas(width, height);
          return canvas.outerHTML;
        },
        on_load: () => {
          cleanup();
          
          const canvas = document.getElementById('rdk-canvas');
          if (!canvas) return;
          
          const ctx = canvas.getContext('2d');
          const ppd = pixelsPerDegree || 50;
          const gw = Math.round(14.7 * ppd);
          const gh = Math.round(5.7 * ppd);
          const cx = Math.floor(width / 2);
          const cy = Math.floor(height / 2);
          const left = cx - Math.floor(gw / 2);
          const top = cy - Math.floor(gh / 2);
          const periodPx = Math.max(2, Math.round(0.8 * ppd));
          const speedPxPerSec = 0.8 * ppd;
          const dirSign = (directionDeg === 0) ? -1 : 1;

          let phase = 0;
          let start = null;
          let lastTs = null;

          const img = ctx.createImageData(gw, gh);

          function renderPhase() {
            ctx.fillStyle = '#808080'; // neutral gray background
            ctx.fillRect(0, 0, width, height);
            
            const data = img.data;
            for (let y = 0; y < gh; y++) {
              for (let x = 0; x < gw; x++) {
                const idx = (y * gw + x) * 4;
                const val = Math.floor(127.5 + 127.5 * Math.sin(2 * Math.PI * (x / periodPx) + phase));
                data[idx] = val;
                data[idx + 1] = val;
                data[idx + 2] = val;
                data[idx + 3] = 255;
              }
            }
            ctx.putImageData(img, left, top);
          }

          function step(ts) {
            if (start === null) start = ts;
            const elapsed = ts - start;
            
            if (elapsed >= adaptorDurationMs) {
              cleanup();
              return;
            }
            
            const dt = lastTs == null ? 0 : (ts - lastTs) / 1000;
            lastTs = ts;
            phase += dirSign * (2 * Math.PI) * (speedPxPerSec / periodPx) * dt;
            renderPhase();
            currentRafId = requestAnimationFrame(step);
          }

          renderPhase();
          currentRafId = requestAnimationFrame(step);
        },
        on_finish: (data) => {
          cleanup();
          data.phase = 'adaptor-grating';
          data.adaptorType = 'grating';
          data.adaptorDirection = directionDeg;
        }
      };
    }

    // FIXED RDK implementation with proper noise dot motion
    function rdkTrial({
      width = 800,
      height = 800,
      directionDeg = 180,
      durationMs = 2000,
      numSets = interleavedSets
    } = {}) {
      const ppd = pixelsPerDegree || 50;
      const aperturePx = Math.round(apertureDeg * ppd);
      const apertureHalf = Math.floor(aperturePx / 2);
      const centerX = Math.floor(width / 2);
      const centerY = Math.floor(height / 2);
      const leftBound = centerX - apertureHalf;
      const rightBound = centerX + apertureHalf;
      const topBound = centerY - apertureHalf;
      const bottomBound = centerY + apertureHalf;

      const numDots = Math.max(50, Math.round(densityDotsPerDeg2 * apertureDeg * apertureDeg));
      const coherentCount = Math.round(numDots * coherence);
      const noiseCount = numDots - coherentCount;
      const dotRadius = Math.max(1, (dotDiameterDeg * ppd) / 2);
      const dotSpeedPxPerSec = dotSpeedDegPerSec * ppd;
      const lifetimeSec = lifetimeMs / 1000;

      return {
        type: jsPsychHtmlKeyboardResponse,
        choices: ['ArrowLeft','ArrowRight'],
        trial_duration: durationMs,
        response_ends_trial: true,
        stimulus: () => {
          const canvas = initGlobalCanvas(width, height);
          return canvas.outerHTML;
        },
        on_load: () => {
          cleanup();
          
          const canvas = document.getElementById('rdk-canvas');
          if (!canvas) return;
          
          const ctx = canvas.getContext('2d');

          const radians = directionDeg * Math.PI / 180;
          const coherentVx = Math.cos(radians) * dotSpeedPxPerSec;
          const coherentVy = Math.sin(radians) * dotSpeedPxPerSec;

          function randInAperture() {
            return {
              x: leftBound + Math.random() * aperturePx,
              y: topBound + Math.random() * aperturePx
            };
          }

          // FIXED: Proper dot initialization 
          function makeDot(isCoherent) {
            const dot = {
              ...randInAperture(),
              ageSec: 0,
              isCoherent
            };
            
            // All dots start with signal direction, but noise dots will be repositioned randomly each frame
            dot.vx = coherentVx;
            dot.vy = coherentVy;
            
            return dot;
          }

          // Initialize dot sets
          const sets = [];
          const dotsPerSet = Math.floor(numDots / numSets);
          const coherentPerSet = Math.floor(coherentCount / numSets);
          
          for (let s = 0; s < numSets; s++) {
            const dots = [];
            for (let i = 0; i < coherentPerSet; i++) {
              dots.push(makeDot(true));
            }
            for (let i = coherentPerSet; i < dotsPerSet; i++) {
              dots.push(makeDot(false));
            }
            sets.push(dots);
          }

          // Distribute remaining dots
          let remaining = numDots - sets.reduce((sum, set) => sum + set.length, 0);
          let remainingCoherent = coherentCount - sets.reduce((sum, set) => sum + set.filter(d => d.isCoherent).length, 0);
          
          for (let i = 0; i < remaining; i++) {
            const isCoherent = i < remainingCoherent;
            sets[i % numSets].push(makeDot(isCoherent));
          }

          function respawn(dot) {
            const p = randInAperture();
            dot.x = p.x;
            dot.y = p.y;
            dot.ageSec = 0;
            
            // All dots keep same signal direction velocity
            dot.vx = coherentVx;
            dot.vy = coherentVy;
          }

          function drawAllDots() {
            ctx.fillStyle = '#808080'; // neutral gray background
            ctx.fillRect(0, 0, width, height);
            
            ctx.strokeStyle = '#606060'; // slightly darker gray for aperture outline
            ctx.lineWidth = 1;
            ctx.strokeRect(leftBound, topBound, aperturePx, aperturePx);
            
            ctx.fillStyle = '#000000'; // black dots
            const dotSize = Math.max(1, Math.round(dotRadius * 2));
            
            ctx.beginPath();
            for (const set of sets) {
              for (const d of set) {
                ctx.rect(Math.floor(d.x - dotRadius), Math.floor(d.y - dotRadius), dotSize, dotSize);
              }
            }
            ctx.fill();
          }

          // FIXED: Standard RDK motion update
          function updateSet(activeSetIdx, dtSec) {
            const set = sets[activeSetIdx];
            for (const d of set) {
              if (d.isCoherent) {
                // Coherent dots move in signal direction
                d.x += d.vx * dtSec;
                d.y += d.vy * dtSec;
              } else {
                // Noise dots get random new position each frame (standard RDK approach)
                const p = randInAperture();
                d.x = p.x;
                d.y = p.y;
              }

              // Handle boundary wrapping for coherent dots only
              if (d.isCoherent) {
                while (d.x < leftBound) d.x += aperturePx;
                while (d.x >= rightBound) d.x -= aperturePx;
                while (d.y < topBound) d.y += aperturePx;
                while (d.y >= bottomBound) d.y -= aperturePx;
              }

              // Limited lifetime
              d.ageSec += dtSec * numSets;
              if (d.ageSec >= lifetimeSec) {
                respawn(d);
              }
            }
          }

          let start = null;
          let frame = 0;
          let lastTs = null;
          const targetFps = 60;
          const frameDuration = 1000 / targetFps;

          function step(ts) {
            if (start === null) start = ts;
            const elapsed = ts - start;
            
            if (elapsed >= durationMs) {
              cleanup();
              return;
            }

            const dtMs = lastTs == null ? frameDuration : (ts - lastTs);
            lastTs = ts;
            const dtSec = dtMs / 1000;

            const activeSetIdx = frame % numSets;
            updateSet(activeSetIdx, dtSec);
            drawAllDots();
            frame += 1;

            currentRafId = requestAnimationFrame(step);
          }

          currentRafId = requestAnimationFrame(step);
        },
        on_finish: (data) => {
          cleanup();
          const correctKey = directionDeg === 0 ? 'arrowright' : 'arrowleft';
          data.correct = jsPsych.pluginAPI.compareKeys(data.response, correctKey);
          data.direction = directionDeg;
          data.coherence = coherence;
          data.lifetimeMs = lifetimeMs;
          data.numSets = numSets;
          data.apertureDeg = apertureDeg;
          data.ppd = pixelsPerDegree || 50;
        }
      };
    }

    function twoPhaseTrial({ adaptorDirDeg, congruent }) {
      const testDirDeg = congruent ? adaptorDirDeg : (adaptorDirDeg === 0 ? 180 : 0);
      const itiMs = randInt(itiMinMs, itiMaxMs);
      
      const tooSlowScreen = {
        type: jsPsychHtmlKeyboardResponse,
        choices: 'NO_KEYS',
        trial_duration: 1500,
        stimulus: `<div class="center"><h3>Too Slow!</h3><p>Please respond faster.</p></div>`
      };

      const test = {
        ...rdkTrial({ directionDeg: testDirDeg, durationMs: testDurationMs }),
        on_finish: (data) => {
          const correctKey = testDirDeg === 0 ? 'arrowright' : 'arrowleft';
          data.correct = jsPsych.pluginAPI.compareKeys(data.response, correctKey);
          data.phase = 'test';
          data.congruent = congruent;
          data.adaptorDirection = adaptorDirDeg;
          data.testDirection = testDirDeg;
        }
      };

      const adaptor = {
        ...gratingAdaptor({ directionDeg: adaptorDirDeg }),
        on_finish: (data) => {
          data.phase = 'adaptor';
          data.congruent = congruent;
          data.adaptorDirection = adaptorDirDeg;
        }
      };

      return {
        timeline: [
          { 
            type: jsPsychHtmlKeyboardResponse, 
            choices: 'NO_KEYS', 
            trial_duration: itiMs, 
            stimulus: '',
            on_load: cleanup
          },
          fixationTrial(),
          adaptor,
          { timeline: [ test ], conditional_function: () => true },
          { 
            timeline: [ tooSlowScreen ], 
            conditional_function: () => {
              const last = jsPsych.data.get().last(1).values()[0];
              return (typeof last.response === 'undefined' || last.response === null);
            }
          }
        ]
      };
    }

    // Build trials
    const totalTrials = 30;
    const blockSize = 30;
    const congruencyList = [
      ...Array.from({ length: totalTrials / 2 }, () => true),
      ...Array.from({ length: totalTrials / 2 }, () => false)
    ];
    
    for (let i = congruencyList.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [congruencyList[i], congruencyList[j]] = [congruencyList[j], congruencyList[i]];
    }
    
    const trials = [];
    for (const cong of congruencyList) {
      const adaptorDir = Math.random() < 0.5 ? 0 : 180;
      trials.push(twoPhaseTrial({ adaptorDirDeg: adaptorDir, congruent: cong }));
    }
    
    const blocks = [];
    for (let i = 0; i < trials.length; i += blockSize) {
      const block = trials.slice(i, i + blockSize);
      blocks.push({ timeline: block });
    }
    
    timeline.push({ timeline: blocks, randomize_order: false });

    function showResultsAndMenu() {
      cleanup();
      
      const data = jsPsych.data.get();
      const tests = data.filter({ phase: 'test' });
      const json = tests.json(true);
      const n = tests.count();
      const acc = n ? Math.round(tests.filter({ correct: true }).count() / n * 100) : 0;
      const meanRt = Math.round(tests.select('rt').mean() || 0);
      
      const byDir = [0, 180].map(dir => {
        const set = tests.filter({ testDirection: dir });
        const nn = set.count();
        const aa = nn ? Math.round(set.filter({ correct: true }).count() / nn * 100) : 0;
        return `${dir === 0 ? 'Right' : 'Left'}: ${aa}% (n=${nn})`;
      }).join(' | ');
      
      const cong = tests.filter({ congruent: true });
      const incong = tests.filter({ congruent: false });
      const rtCon = Math.round(cong.select('rt').mean() || 0);
      const rtIncon = Math.round(incong.select('rt').mean() || 0);
      const deltaRt = (rtCon && rtIncon) ? (rtCon - rtIncon) : 0;
      
      const container = document.createElement('div');
      container.className = 'center';
      container.innerHTML = `
        <h3>Results</h3>
        <p>Trials: <b>${n}</b> | Accuracy: <b>${acc}%</b> | Mean RT: <b>${meanRt} ms</b></p>
        <p>By Direction — ${byDir}</p>
        <p>Congruency RT: Con=${rtCon} ms, Incon=${rtIncon} ms, ΔRT = Con − Incon = <b>${deltaRt} ms</b></p>
        <p><strong>Expected for motion adaptation: ΔRT > 0 (congruent slower than incongruent)</strong></p>
        <p>
          <button id="btn-rerun">Run again</button>
          <button id="btn-show-data">Show raw data</button>
        </p>
        <div id="data-wrap" style="display:none; margin-top:16px;">
          <pre style="white-space:pre-wrap; max-height:340px; overflow:auto; background:#222; color:#ddd; padding:12px; border-radius:6px;">${json}</pre>
        </div>
      `;
      
      document.body.innerHTML = '';
      document.body.appendChild(container);
      
      document.getElementById('btn-rerun').addEventListener('click', () => {
        window.location.reload();
      });
      
      document.getElementById('btn-show-data').addEventListener('click', () => {
        const wrap = document.getElementById('data-wrap');
        wrap.style.display = wrap.style.display === 'none' ? 'block' : 'none';
      });
    }

    jsPsych.run(timeline).then(() => {
      showResultsAndMenu();
    });
  </script>
</html>
